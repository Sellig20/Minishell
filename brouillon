		// if (((t_words *)tmp_words->content)->token == TOK_DOLL)
		// {
		// 	res = ft_check_after_doll(((t_words *)tmp_words->next->content)->word);
		// 	new_echo = ft_res(envcp, res, ((t_words *)tmp_words->next->content)->word);
		// 	printf("NEW BEBEOW = %s\n", new_echo);
		// 	free(new_echo);
		// }


char	*ft_res(t_list **envcp, int res, char *word)
{
	int	len;
	int	i;
	char *new_word;
	t_list *tmp_envcp;
	int	len_one_env;
	char *new_word;
	char *tmp_4;
	int j4;
	char *reste_4;
	char *nul_4;
	int	i;
	int j4;
	int	h;
	int	len;
	int	len_one_env;


	len = ft_strlen(word);
	tmp_envcp = *envcp;
	len_one_env = 0;
	tmp_4 = 0;
	j4 = 0;
	reste_4 = 0;
	int	k = 0;
	k = ft_strlen(word);
	int ki = 0;
	h = 0;
	if (res == 1)
	{
		i = 1;
@@ -109,7 +109,7 @@ char	*ft_res(t_list **envcp, int res, char *word)
			if (ft_strncmp(((t_cpenv *)tmp_envcp->content)->one_env, word, len) == 0)
			{
				len_one_env = ft_strlen((((t_cpenv *)tmp_envcp->content)->one_env)) - (len + 1);
				new_word = malloc(sizeof(char) * len_one_env);
				new_word = malloc(sizeof(char) * len_one_env + 1);
				while (((t_cpenv *)tmp_envcp->content)->one_env[len + 1 + i])
				{
					new_word[i] = ((t_cpenv *)tmp_envcp->content)->one_env[len + 1 + i];
@@ -120,42 +120,40 @@ char	*ft_res(t_list **envcp, int res, char *word)
		}
		if (i == 0)
		{
			new_word = malloc(sizeof(char) * 1);
			new_word = malloc(sizeof(char) * 1 + 1);
			new_word[i] = '\0';
		}
	}
	if (res == 4)
	{
		i = 0;
		j4 = 0;
		printf("k = %d\n", k);
		while ((word[i] >= 'a' && word[i] <= 'z') || (word[i] >= '0' && word[i] <= '9')
			|| (word[i] >= 'A' && word[i] <= 'Z'))
			i++;
		tmp_4 = malloc(sizeof(char) * (i + 1));
		reste_4 = malloc(sizeof(char) * (len - i) + 1);
		while (j4 < i)
		{
			tmp_4[j4] = word[j4];
			j4++;
		}
		printf("i = %d\n", i);
		while (i <= k)
		tmp_4[j4]  = '\0';
		while (i < len && word[i])
		{
			//i = 0;
			(void)reste_4;
			(void)ki;
			printf("reste 4 =============>>>>>>>>>>> %c\n", word[i]);
			reste_4[h] = word[i];
			i++;
			h++;
		}
		tmp_4[j4]  = '\0';
		reste_4[h] = '\0';
		while (tmp_envcp)
		{
			j4 = 0;
			len = ft_strlen(tmp_4);
			if (ft_strncmp(((t_cpenv *)tmp_envcp->content)->one_env, tmp_4, len) == 0)
			{
				len_one_env = ft_strlen((((t_cpenv *)tmp_envcp->content)->one_env)) - (len + 1);
				new_word = malloc(sizeof(char) * len_one_env);
				new_word = malloc(sizeof(char) * len_one_env + 1);
				while (((t_cpenv *)tmp_envcp->content)->one_env[len + 1 + j4])
				{
					new_word[j4] = ((t_cpenv *)tmp_envcp->content)->one_env[len + 1 + j4];
@@ -166,36 +164,48 @@ char	*ft_res(t_list **envcp, int res, char *word)
		}
		if (j4 == 0)
		{
			new_word = malloc(sizeof(char) * 1);
			new_word[j4] = '\0';
			nul_4 = malloc(sizeof(char) * 1 + 1);
			nul_4[j4] = '\0';
			new_word = ft_strjoin(nul_4, reste_4);
			free(reste_4);
			free(nul_4);
			free(tmp_4);
			return (new_word);
		}
		new_word = ft_strjoin(new_word, tmp_4);
		new_word = ft_strjoin(new_word, reste_4);
		free(reste_4);
		free(tmp_4);
	}
	return (new_word);
}



// t_list	*ft_new_maillon(t_list **tentative, t_list **envcp, t_data *x)
// {
// 	int res;
// 	t_list *new_maillon;
// 	t_list *tentativecmd;
// 	char	*new_echo;

// 	tentativecmd = *tentative;
// 	new_maillon = NULL;
// 	res = ft_check_after_doll(((t_words *)tentativecmd->next->content)->word);
// 	// printf("res = %d\n", res);
// 	new_echo = ft_res(envcp, res, ((t_words *)tentativecmd->next->content)->word, x);
// 	// printf("new echo = %s\n", new_echo);
// 	new_maillon = ft_lstnew((void *) words_init(new_echo, TOK_WORD));
// 	// printf("new_maillon = %s\n", ((t_words *)new_maillon->content)->word);
// 	free(new_echo);
// 	return (new_maillon);
// }

// t_list	**ft_expand_cmd(t_list **segment, t_list **envcp, t_data *x)
// {
// 	t_list *maill_malloc_echo;
// 	t_list *new_maill = NULL;
// 	t_list *tentativecmd;
// 	t_list **remplircmd;

// 	x->key = 1;
// 	remplircmd = malloc(sizeof(t_list*));
// 	if (!remplircmd)
// 		return (NULL);
// 	*remplircmd = NULL;
// 	tentativecmd = ((t_cmdredir*)(*segment)->content)->cmd;
// 	if (tentativecmd->content == NULL)
// 	{
// 		(*remplircmd) = ft_lstnew(NULL);
// 		return (remplircmd);
// 	}
// 	while (tentativecmd)
// 	{
// 		if (((t_words *)tentativecmd->content)->token == TOK_DOLL && tentativecmd->next) //creer le rsultat si tok dollar
// 		{
// 			new_maill = ft_new_maillon(&tentativecmd, envcp, x);
// 			remplircmd = (t_list **)ft_lstadd_back2(remplircmd, new_maill);
// 			tentativecmd = tentativecmd->next;
// 		}
// 		else
// 		{
// 			maill_malloc_echo = ft_lstnew((void *) words_init(((t_words *)tentativecmd->content)->word, TOK_WORD)); // sinon renvoyer
// 			remplircmd = (t_list **)ft_lstadd_back2(remplircmd, maill_malloc_echo);
// 		}
// 		tentativecmd = tentativecmd->next;
// 	}
// 	if (!(*remplircmd))
// 		(*remplircmd) = ft_lstnew(NULL);
// 	return (remplircmd);
// }
