		// if (((t_words *)tmp_words->content)->token == TOK_DOLL)
		// {
		// 	res = ft_check_after_doll(((t_words *)tmp_words->next->content)->word);
		// 	new_echo = ft_res(envcp, res, ((t_words *)tmp_words->next->content)->word);
		// 	printf("NEW BEBEOW = %s\n", new_echo);
		// 	free(new_echo);
		// }


// char	*ft_res(t_list **envcp, int res, char *word)
// {
// 	int	len;
// 	int	i;
// 	char *new_word;
// 	t_list *tmp_envcp;
// 	int	len_one_env;
// 	char *new_word;
// 	char *tmp_4;
// 	int j4;
// 	char *reste_4;
// 	char *nul_4;
// 	int	i;
// 	int j4;
// 	int	h;
// 	int	len;
// 	int	len_one_env;


// 	len = ft_strlen(word);
// 	tmp_envcp = *envcp;
// 	len_one_env = 0;
// 	tmp_4 = 0;
// 	j4 = 0;
// 	reste_4 = 0;
// 	int	k = 0;
// 	k = ft_strlen(word);
// 	int ki = 0;
// 	h = 0;
// 	if (res == 1)
// 	{
// 		i = 1;
// @@ -109,7 +109,7 @@ char	*ft_res(t_list **envcp, int res, char *word)
// 			if (ft_strncmp(((t_cpenv *)tmp_envcp->content)->one_env, word, len) == 0)
// 			{
// 				len_one_env = ft_strlen((((t_cpenv *)tmp_envcp->content)->one_env)) - (len + 1);
// 				new_word = malloc(sizeof(char) * len_one_env);
// 				new_word = malloc(sizeof(char) * len_one_env + 1);
// 				while (((t_cpenv *)tmp_envcp->content)->one_env[len + 1 + i])
// 				{
// 					new_word[i] = ((t_cpenv *)tmp_envcp->content)->one_env[len + 1 + i];
// @@ -120,42 +120,40 @@ char	*ft_res(t_list **envcp, int res, char *word)
// 		}
// 		if (i == 0)
// 		{
// 			new_word = malloc(sizeof(char) * 1);
// 			new_word = malloc(sizeof(char) * 1 + 1);
// 			new_word[i] = '\0';
// 		}
// 	}
// 	if (res == 4)
// 	{
// 		i = 0;
// 		j4 = 0;
// 		printf("k = %d\n", k);
// 		while ((word[i] >= 'a' && word[i] <= 'z') || (word[i] >= '0' && word[i] <= '9')
// 			|| (word[i] >= 'A' && word[i] <= 'Z'))
// 			i++;
// 		tmp_4 = malloc(sizeof(char) * (i + 1));
// 		reste_4 = malloc(sizeof(char) * (len - i) + 1);
// 		while (j4 < i)
// 		{
// 			tmp_4[j4] = word[j4];
// 			j4++;
// 		}
// 		printf("i = %d\n", i);
// 		while (i <= k)
// 		tmp_4[j4]  = '\0';
// 		while (i < len && word[i])
// 		{
// 			//i = 0;
// 			(void)reste_4;
// 			(void)ki;
// 			printf("reste 4 =============>>>>>>>>>>> %c\n", word[i]);
// 			reste_4[h] = word[i];
// 			i++;
// 			h++;
// 		}
// 		tmp_4[j4]  = '\0';
// 		reste_4[h] = '\0';
// 		while (tmp_envcp)
// 		{
// 			j4 = 0;
// 			len = ft_strlen(tmp_4);
// 			if (ft_strncmp(((t_cpenv *)tmp_envcp->content)->one_env, tmp_4, len) == 0)
// 			{
// 				len_one_env = ft_strlen((((t_cpenv *)tmp_envcp->content)->one_env)) - (len + 1);
// 				new_word = malloc(sizeof(char) * len_one_env);
// 				new_word = malloc(sizeof(char) * len_one_env + 1);
// 				while (((t_cpenv *)tmp_envcp->content)->one_env[len + 1 + j4])
// 				{
// 					new_word[j4] = ((t_cpenv *)tmp_envcp->content)->one_env[len + 1 + j4];
// @@ -166,36 +164,48 @@ char	*ft_res(t_list **envcp, int res, char *word)
// 		}
// 		if (j4 == 0)
// 		{
// 			new_word = malloc(sizeof(char) * 1);
// 			new_word[j4] = '\0';
// 			nul_4 = malloc(sizeof(char) * 1 + 1);
// 			nul_4[j4] = '\0';
// 			new_word = ft_strjoin(nul_4, reste_4);
// 			free(reste_4);
// 			free(nul_4);
// 			free(tmp_4);
// 			return (new_word);
// 		}
// 		new_word = ft_strjoin(new_word, tmp_4);
// 		new_word = ft_strjoin(new_word, reste_4);
// 		free(reste_4);
// 		free(tmp_4);
// 	}
// 	return (new_word);
// }



// // t_list	*ft_new_maillon(t_list **tentative, t_list **envcp, t_data *x)
// // {
// // 	int res;
// // 	t_list *new_maillon;
// // 	t_list *tentativecmd;
// // 	char	*new_echo;

// // 	tentativecmd = *tentative;
// // 	new_maillon = NULL;
// // 	res = ft_check_after_doll(((t_words *)tentativecmd->next->content)->word);
// // 	// printf("res = %d\n", res);
// // 	new_echo = ft_res(envcp, res, ((t_words *)tentativecmd->next->content)->word, x);
// // 	// printf("new echo = %s\n", new_echo);
// // 	new_maillon = ft_lstnew((void *) words_init(new_echo, TOK_WORD));
// // 	// printf("new_maillon = %s\n", ((t_words *)new_maillon->content)->word);
// // 	free(new_echo);
// // 	return (new_maillon);
// // }

// // t_list	**ft_expand_cmd(t_list **segment, t_list **envcp, t_data *x)
// // {
// // 	t_list *maill_malloc_echo;
// // 	t_list *new_maill = NULL;
// // 	t_list *tentativecmd;
// // 	t_list **remplircmd;

// // 	x->key = 1;
// // 	remplircmd = malloc(sizeof(t_list*));
// // 	if (!remplircmd)
// // 		return (NULL);
// // 	*remplircmd = NULL;
// // 	tentativecmd = ((t_cmdredir*)(*segment)->content)->cmd;
// // 	if (tentativecmd->content == NULL)
// // 	{
// // 		(*remplircmd) = ft_lstnew(NULL);
// // 		return (remplircmd);
// // 	}
// // 	while (tentativecmd)
// // 	{
// // 		if (((t_words *)tentativecmd->content)->token == TOK_DOLL && tentativecmd->next) //creer le rsultat si tok dollar
// // 		{
// // 			new_maill = ft_new_maillon(&tentativecmd, envcp, x);
// // 			remplircmd = (t_list **)ft_lstadd_back2(remplircmd, new_maill);
// // 			tentativecmd = tentativecmd->next;
// // 		}
// // 		else
// // 		{
// // 			maill_malloc_echo = ft_lstnew((void *) words_init(((t_words *)tentativecmd->content)->word, TOK_WORD)); // sinon renvoyer
// // 			remplircmd = (t_list **)ft_lstadd_back2(remplircmd, maill_malloc_echo);
// // 		}
// // 		tentativecmd = tentativecmd->next;
// // 	}
// // 	if (!(*remplircmd))
// // 		(*remplircmd) = ft_lstnew(NULL);
// // 	return (remplircmd);
// // }


// int	ft_strlen_option(t_list **cmd_line)
// {
// 	t_list	*cmd;
// 	int		i;
// 	int		len;
// 	char	*tmp;
// 	int		len_finale;

// 	i = 0;
// 	len = 0;
// 	len_finale = 0;
// 	cmd = *cmd_line;
// 	while (cmd)
// 	{
// 		if (cmd->content)
// 			tmp = ((t_words *)cmd->content)->word;
// 		else
// 			return (0);
// 		if (tmp[0] == '-')
// 		{
// 			while (tmp[i] != '\0')
// 				i++;
// 			len = i - 1;
// 		}
// 		len_finale += len;
// 		cmd = cmd->next;
// 	}
// 	return (len_finale);
// }

// void	ft_error_cannot_access(char *str, char *first)
// {
// 	ft_putstr_fd(first, 2);
// 	ft_putstr_fd(": cannot access '", 2);
// 	ft_putstr_fd(str, 2);
// 	ft_putstr_fd("': NOOOOOOOOOOOOOOO such file or directory\n", 2);
// }

// int	ft_join_option_error(char *str, char *first, t_list **cmd)
// {
// 	t_list	*cmd_line;

// 	cmd_line = *cmd;
// 	str = ((t_words *)cmd_line->content)->word;
// 	return (ft_error_cannot_access(str, first) , 1);
// }

// char	*ft_cp_options(t_list *cmd_line, int len, char *tt, char *first, char *res)
// {
// 	int	i;
// 	int	j;

// 	i = 0;
// 	j = 1;
// 	while (cmd_line)
// 	{
// 		tt = ((t_words *)cmd_line->content)->word;
// 		len = ft_strlen(tt);
// 		if (len == 1)
// 			return (ft_join_option_error(tt, first, &cmd_line), NULL);
// 		else if (len > 1 && tt[0] == '-')
// 		{
// 			i = 1;
// 			res[0] = '-';
// 			while(i < len && tt[i])
// 			{
// 				res[j] = tt[i];
// 				i++;
// 				j++;
// 			}
// 		}
// 		cmd_line = cmd_line->next;
// 	}
// 	res[j] = '\0';
// 	return (res);
// }

// char	*ft_join_options(t_list **cmd, t_data *x)
// {
// 	t_list	*cmd_line;
// 	char	*tt;
// 	char	*res;
// 	char	*first;
// 	int		len;

// 	len = 0;
// 	cmd_line = *cmd;
// 	first = ((t_words *)cmd_line->content)->word;
// 	tt = NULL;
// 	if (!cmd)
// 		return (NULL);
// 	x->i_len = ft_strlen_option(&cmd_line);
// 	res = malloc(sizeof(char) * (x->i_len + 2));
// 	ft_bzero(res, x->i_len + 1);
// 	if (!res)
// 		return (NULL);
// 	cmd_line = cmd_line->next;
// 	res = ft_cp_options(cmd_line, len, tt, first, res);
// 	return (res);
// }


//////////////////////////////////////////////////////////////////////////////////
// int	ft_read_outfile_append_builtin(char *outfile)
// {
// 	return (open(outfile, O_CREAT | O_WRONLY | O_APPEND, 0644));
// }

// int	ft_read_outfile_builtin(char *outfile)
// {
// 	return (open(outfile, O_CREAT | O_WRONLY | O_TRUNC, 0644));
// }

// void	ft_redirection_in_builtin(int infile)
// {
// 	dup2(infile, STDIN_FILENO);
// 	close(infile);
// }

// void	ft_redirection_out_builtin(int outfile)
// {
// 	dup2(outfile, STDOUT_FILENO);
// 	close(outfile);
// }

// int	ft_read_infile_builtin(char *infile)
// {
// 	return (open(infile, O_RDONLY));
// }

// char	*ft_expand_heredoc(char *line, t_list **cpenv, int res, t_data *x)
// {
// 	int		i;
// 	int		j;
// 	char	*final;

// 	i = 1;
// 	j = 0;
// 	final = malloc(sizeof(char) * ft_strlen(line - 1) + 1);
// 	if (!final)
// 		return (NULL);
// 	while (line[i])
// 	{
// 		final[j] = line[i];
// 		i++;
// 		j++;
// 	}
// 	res = ft_check_after_doll(final);
// 	final = ft_result(cpenv, res, final, x);
// 	return (final);
// }

// int	ft_read_infile_heredoc_builtin(char *lim, char *line, t_list **cpenv, t_data *x)
// {
// 	int	fd;
// 	int	res;

// 	res = 0;
// 	fd = open(".HEREDOC", O_CREAT | O_WRONLY | O_TRUNC, 0644);
// 	if (fd < 0)
// 	{
// 		ft_putstr_fd("error heredoc\n", 2);
// 		return (EXIT_FAILURE);
// 	}
// 	while (1)
// 	{
// 		write(1, ">", 1);
// 		line = readline(STDIN_FILENO);
// 		if (ft_strncmp(line, "$", 1) == 0)
// 			line = ft_expand_heredoc(line, cpenv, res, x);
// 		if (ft_strncmp(lim, line, ft_strlen(lim)) == 0)
// 			break;
// 		write(fd, line, ft_strlen(line));
// 		write(fd, "\n", 1);
// 		if (line[0] == '\0')
// 			write(1, "\n", 1);
// 		line = ft_strjoin(line, "\n");
// 	}
// 	free(line);
// 	return (fd);
// }

// void	ft_catch_file_builtin(t_list **redir, t_data *x, t_list **cpenv)
// {
// 	t_list	*tmp;
// 	int		file;

// 	file = 0;
// 	tmp = *redir;
// 	(void)cpenv;
// 	if (((t_words *)tmp->content) == NULL)
// 		return ;
// 	while (tmp) // chaque maillon de mes redir
// 	{
// 		if ( ((t_words *)tmp->content)->token == TOK_FRFR) //heredoc
// 		{
// 			file = ft_read_infile_heredoc_builtin(((t_words *)tmp->next->content)->word, x->line, cpenv, x);
// 			if (file < 0)
// 				ft_exist_error(((t_words *)tmp->next->content)->word);
// 			else
// 				ft_redirection_in_builtin(file);
// 		}
// 		else if (((t_words *)tmp->content)->token == TOK_FROM) //in
// 		{
// 			file = ft_read_infile_builtin(((t_words *)tmp->next->content)->word);
// 			if (file < 0)
// 				ft_exist_error(((t_words *)tmp->next->content)->word);
// 			else
// 				ft_redirection_in_builtin(file);
// 		}
// 		else if (((t_words *)tmp->content)->token == TOK_TOTO)//append
// 		{
// 			file = ft_read_outfile_append_builtin(((t_words *)tmp->next->content)->word);
// 			if (file < 0)
// 				ft_perm_error(((t_words *)tmp->next->content)->word);
// 			else
// 				ft_redirection_out_builtin(file);
// 		}
// 		else if (((t_words *)tmp->content)->token == TOK_TO)//out
// 		{
// 			file = ft_read_outfile_builtin(((t_words *)tmp->next->content)->word);
// 			x->outfile = file;
// 			if (x->outfile < 0)
// 				ft_perm_error(((t_words *)tmp->next->content)->word);
// 		}
// 		tmp = tmp->next;
// 	}
// }

/////////////////////////////////////////////////////////////////////////////


// int	ft_read_infile_t(char *infile)
// {
// 	return (open(infile, O_RDONLY));
// }

// char	*ft_expand_heredoc_t(char *line, t_list **cpenv, int res, t_data *x)
// {
// 	int		i;
// 	int		j;
// 	char	*final;

// 	i = 1;
// 	j = 0;
// 	final = malloc(sizeof(char) * ft_strlen(line - 1) + 1);
// 	if (!final)
// 		return (NULL);
// 	while (line[i])
// 	{
// 		final[j] = line[i];
// 		i++;
// 		j++;
// 	}
// 	res = ft_check_after_doll(final);
// 	final = ft_result(cpenv, res, final, x);
// 	return (final);
// }

// int	ft_read_infile_heredoc_t(char *lim, char *line, t_list **cpenv, t_data *x)
// {
// 	int	fd;
// 	int	res;

// 	res = 0;
// 	fd = open(".HEREDOC", O_CREAT | O_WRONLY | O_TRUNC, 0644);
// 	if (fd < 0)
// 	{
// 		ft_putstr_fd("error heredoc\n", 2);
// 		return (EXIT_FAILURE);
// 	}
// 	while (1)
// 	{
// 		write(1, ">", 1);
// 		line = readline(STDIN_FILENO);
// 		if (ft_strncmp(line, "$", 1) == 0)
// 			line = ft_expand_heredoc_t(line, cpenv, res, x);
// 		if (ft_strncmp(lim, line, ft_strlen(lim)) == 0)
// 			break;
// 		write(fd, line, ft_strlen(line));
// 		write(fd, "\n", 1);
// 		if (line[0] == '\0')
// 			write(1, "\n", 1);
// 		line = ft_strjoin(line, "\n");
// 	}
// 	free(line);
// 	return (fd);
// }

// int	ft_read_outfile_append_t(char *outfile)
// {
// 	return (open(outfile, O_CREAT | O_WRONLY | O_APPEND, 0644));
// }

// int	ft_read_outfile_t(char *outfile)
// {
// 	return (open(outfile, O_CREAT | O_WRONLY | O_TRUNC, 0644));
// }

// void	ft_redirection_in_t(int infile)
// {
// 	dup2(infile, STDIN_FILENO);
// 	close(infile);
// }

// void	ft_redirection_out_t(int outfile)
// {
// 	dup2(outfile, STDOUT_FILENO);
// 	close(outfile);
// }

// void	ft_catch_file_tog_t(t_list **redir, t_data *x, t_list **cpenv, int flag)
// {
// 	t_list	*tmp;
// 	int		file;

// 	file = 0;
// 	tmp = *redir;
// 	(void)cpenv;
// 	if (((t_words *)tmp->content) == NULL)
// 		return ;
// 	while (tmp) // chaque maillon de mes redir
// 	{
// 		if ( ((t_words *)tmp->content)->token == TOK_FRFR) //heredoc
// 		{
// 			file = ft_read_infile_heredoc_t(((t_words *)tmp->next->content)->word, x->line, cpenv, x);
// 			if (file < 0)
// 				ft_exist_error(((t_words *)tmp->next->content)->word);
// 			else
// 				ft_redirection_in_t(file);
// 		}
// 		else if ( ((t_words *)tmp->content)->token == TOK_FROM) //in
// 		{
// 		//	dprintf(2, "-------------------    <     -------------   %s  -----\n", ((t_words *)tmp->content)->word);
// 			file = ft_read_infile_t(((t_words *)tmp->next->content)->word);
// 			if (file < 0)
// 				ft_exist_error(((t_words *)tmp->next->content)->word);
// 			else
// 				ft_redirection_in_t(file);
// 		}
// 		else if ( ((t_words *)tmp->content)->token == TOK_TOTO)//append
// 		{
// 			file = ft_read_outfile_append_t(((t_words *)tmp->next->content)->word);
// 			if (file < 0)
// 				ft_perm_error(((t_words *)tmp->next->content)->word);
// 			else
// 				ft_redirection_out_t(file);
// 		}
// 		else if ( ((t_words *)tmp->content)->token == TOK_TO)//out
// 		{
// 		//	dprintf(2, "-------------------    >     ---------------  %s   ---------\n", ((t_words *)tmp->content)->word);
// 			file = ft_read_outfile_t(((t_words *)tmp->next->content)->word);
// 			x->outfile = file;
// 			if (file < 0)
// 				ft_perm_error(((t_words *)tmp->next->content)->word);
// 			else if (flag == 1)
// 			{
// 				dprintf(2, "je suis builtin et surtout echo donc je me barre de catch file !!!\n");
// 				return ;
// 			}
// 			else
// 				ft_redirection_out_t(file);
// 		}
// 		tmp = tmp->next;
// 	}
// }
